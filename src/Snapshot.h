// Snapshot.h
#ifndef SNAPSHOT_H
#define SNAPSHOT_H

#include "Netlist.h"
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <vector>

class Snapshot {
public:
    struct ComponentState {
        std::string name;
        double v_prev;
        double i_prev;
        bool is_on;
    };

    double sim_time;
    std::vector<ComponentState> components;

    // Salva snapshot em arquivo binário
    bool save_binary(const std::string& filename) const {
        std::ofstream file(filename, std::ios::binary);
        if (!file) return false;

        // Escreve tempo de simulação
        file.write(reinterpret_cast<const char*>(&sim_time), sizeof(sim_time));

        // Escreve número de componentes
        size_t num_components = components.size();
        file.write(reinterpret_cast<const char*>(&num_components), sizeof(num_components));

        // Escreve cada componente
        for (const auto& c : components) {
            // Nome (tamanho + string)
            size_t name_len = c.name.size();
            file.write(reinterpret_cast<const char*>(&name_len), sizeof(name_len));
            file.write(c.name.c_str(), name_len);

            // Estados
            file.write(reinterpret_cast<const char*>(&c.v_prev), sizeof(c.v_prev));
            file.write(reinterpret_cast<const char*>(&c.i_prev), sizeof(c.i_prev));
            file.write(reinterpret_cast<const char*>(&c.is_on), sizeof(c.is_on));
        }

        return file.good();
    }

    // Carrega snapshot de arquivo binário
    bool load_binary(const std::string& filename) {
        std::ifstream file(filename, std::ios::binary);
        if (!file) return false;

        // Lê tempo de simulação
        file.read(reinterpret_cast<char*>(&sim_time), sizeof(sim_time));

        // Lê número de componentes
        size_t num_components;
        file.read(reinterpret_cast<char*>(&num_components), sizeof(num_components));

        components.clear();
        components.reserve(num_components);

        // Lê cada componente
        for (size_t i = 0; i < num_components; i++) {
            ComponentState c;

            // Nome
            size_t name_len;
            file.read(reinterpret_cast<char*>(&name_len), sizeof(name_len));
            c.name.resize(name_len);
            file.read(&c.name[0], name_len);

            // Estados
            file.read(reinterpret_cast<char*>(&c.v_prev), sizeof(c.v_prev));
            file.read(reinterpret_cast<char*>(&c.i_prev), sizeof(c.i_prev));
            file.read(reinterpret_cast<char*>(&c.is_on), sizeof(c.is_on));

            components.push_back(c);
        }

        return file.good();
    }

    // Salva snapshot em formato texto legível
    bool save_text(const std::string& filename) const {
        std::ofstream file(filename);
        if (!file) return false;

        file << std::setprecision(16) << std::scientific;
        file << "# Circuit Snapshot - Steady State\n";
        file << "# Generated by LLC Resonant Converter Simulator\n";
        file << "sim_time " << sim_time << "\n";
        file << "num_components " << components.size() << "\n\n";

        for (const auto& c : components) {
            file << "component " << c.name << "\n";
            file << "  v_prev " << c.v_prev << "\n";
            file << "  i_prev " << c.i_prev << "\n";
            file << "  is_on " << (c.is_on ? "true" : "false") << "\n";
        }

        return true;
    }

    // Carrega snapshot de formato texto
    bool load_text(const std::string& filename) {
        std::ifstream file(filename);
        if (!file) return false;

        std::string line;
        components.clear();

        while (std::getline(file, line)) {
            if (line.empty() || line[0] == '#') continue;

            std::istringstream iss(line);
            std::string key;
            iss >> key;

            if (key == "sim_time") {
                iss >> sim_time;
            }
            else if (key == "component") {
                ComponentState c;
                iss >> c.name;

                // Lê próximas 3 linhas
                for (int i = 0; i < 3; i++) {
                    if (!std::getline(file, line)) return false;
                    std::istringstream iss2(line);
                    std::string attr;
                    iss2 >> attr;

                    if (attr == "v_prev") iss2 >> c.v_prev;
                    else if (attr == "i_prev") iss2 >> c.i_prev;
                    else if (attr == "is_on") {
                        std::string val;
                        iss2 >> val;
                        c.is_on = (val == "true");
                    }
                }
                components.push_back(c);
            }
        }

        return true;
    }

    // Cria snapshot a partir de um Netlist
    static Snapshot from_netlist(const Netlist& netlist) {
        Snapshot snap;
        snap.sim_time = netlist.get_time();

        for (const auto& c : netlist.get_components()) {
            ComponentState cs;
            cs.name = c.name;
            cs.v_prev = c.v_prev;
            cs.i_prev = c.i_prev;
            cs.is_on = c.is_on;
            snap.components.push_back(cs);
        }

        return snap;
    }

    // Aplica snapshot a um Netlist
    bool apply_to_netlist(Netlist& netlist) const {
        netlist.set_time(sim_time);

        for (const auto& cs : components) {
            auto* comp = netlist.find_component(cs.name);
            if (!comp) {
                std::cerr << "AVISO: Componente '" << cs.name
                    << "' não encontrado no netlist\n";
                continue;
            }

            comp->v_prev = cs.v_prev;
            comp->i_prev = cs.i_prev;
            comp->is_on = cs.is_on;
        }

        return true;
    }

    // Imprime resumo do snapshot
    void print_summary(std::ostream& os = std::cout) const {
        os << "\n=== SNAPSHOT SUMMARY ===\n";
        os << "Simulation time: " << sim_time << " s\n";
        os << "Number of components: " << components.size() << "\n\n";

        os << "Component States:\n";
        os << std::setprecision(6) << std::fixed;

        for (const auto& c : components) {
            os << "  " << std::left << std::setw(10) << c.name << ": ";

            bool has_reactive = (std::abs(c.v_prev) > 1e-12 || std::abs(c.i_prev) > 1e-12);
            bool is_switch = (c.is_on || std::string(c.name).find("D") == 0 ||
                std::string(c.name).find("S") == 0);

            if (has_reactive) {
                os << "V=" << std::setw(12) << c.v_prev << " V  "
                    << "I=" << std::setw(12) << c.i_prev << " A";
            }

            if (is_switch) {
                os << (has_reactive ? "  " : "")
                    << "Switch: " << (c.is_on ? "ON" : "OFF");
            }

            if (!has_reactive && !is_switch) {
                os << "No stored state";
            }

            os << "\n";
        }
        os << std::endl;
    }
};

#endif // SNAPSHOT_H